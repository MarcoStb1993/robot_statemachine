#  Statemachine

The statemachine's core components will be explained first and it's usage afterwards, including examples and tutorials for writing plugins, including them into the statemachine and setting up a robot.

## Documentation

The statemachine consists of various non-customizable and custom states that are based on the [Base State](#base-state). The former [non-customizable states](#non-customizable-states) and the [Base State](#base-state) are a part of this package containing the statemachine's basics.  
To handle state transitions the [State Interface](#state-interface) is used. [Robot Control Mux](#robot-control-mux) coordinates the actual control of the robot's movement while the [Service Provider](#service-provider) contains services, publishers and subscribers for communication between states and updating the GUI.

### Base State

The base state for all states of the statemachine features the following four main functions:
* onSetup
* onEntry
* onActive
* onExit

The function `onSetup` is called immediately after it was constructed and should be used to initialize the state. The function `onEntry` is run before the state's `onActive` method is executed for the first time and should be used to start up the processing in the state. The latter is the state's primary method that is executed periodically and contains it's main logic. `onExit` is called before the state will be destroyed and should take care of leaving the state cleanly.

To realize interrupts in the statemachine, the following five functions need to be implemented:
* onExplorationStart
* onExplorationStop
* onWaypointFollowingStart
* onWaypointFollowingStop
* onInterrupt

These functions handle commands issued from the GUI or the use of teleoperation by telling the current state which command or interrupt occurred and let the state handle it. The method `onInterrupt` receives the type of interrupt which are also defined in the Base State and are listed below:
* INTERRUPT\_END: Former interrupt ended (only relevant to specific interrupt handlers)
* EMERGENCY\_STOP\_INTERRUPT: Emergency Software Stop was pushed in the GUI
* TELEOPERATION\_INTERRUPT: Teleoperation was used
* SIMPLE\_GOAL\_INTERRUPT: A navigation goal was issued through the RViz GUI

The four other methods receive a reference to a bool and a string variable. The former informs if the request was successful and the desired action will be executed (true) or not (false) and the latter features a descriptive text.

The Base State holds a reference to the [State Interface](#state-interface) which has to be used for state transitions. It also has a variable with it's name that is necessary to display the current state in the GUI and needs to be set in the `onSetup` or `onEntry` method.

### State Interface

The State Interface holds a reference to the current state and handles state transitions. It also provides references to plugins created for exploration, navigation, mapping or routines to the states.
The State Interface provides the method `transitionToVolatileState` which will initiate a transition to the state provided as an argument. The provided argument is a `boost::shared_ptr` of the Base State type. This can be one of the known [non-customizable states](#non-customizable-states) or a custom state defined through a plugin. 

To access these plugins State Interface offers the method `getPluginState` which takes the plugin type and optionally a plugin routine name as parameters. The former can be one of the following types:
* CALCULATEGOAL\_STATE
* NAVIGATION\_STATE
* MAPPING\_STATE
* ROUTINE\_STATE

For a *ROUTINE_STATE* the routine name needs to be provided as well, otherwise this parameter can remain empty. The other plugin states are set by parameters provided to State Interface on launch.

State Interface subscribes to the *stateInfo* and *simpleGoal* topics to issue interrupts to the currently active state. Furthermore, it offers the two services *startStopExploration* and *startStopWaypointFollowing* which call the particular function in the active state.

The State Interface updates the currently active state periodically though it's `awake` function. This function also executes the state transition initiated by `transitionToVolatileState` and calls the active state's methods.

### Robot Control Mux

The Robot Control Mux (=Multiplexer) controls the velocity commands sent to the ROS node interfacing the motor controllers. In a simple configuration a navigation or teleoperation node would output velocity commands that will be received by the motor controller interface and move the robot. To enable high level control of the input the motor controller receives, the Robot Control Mux should be the only node in the setup publishing directly on the topic the motor controller interface subscribes to.  

Velocity commands generated by navigation should be published to an autonomy topic and velocity commands issued by teleoperation to a teleoperation topic. These two topics are subscribed by the Robot Control Mux that decides which or if any topic will be conducted. The two input and the output topic's name are set by parameters at launch.

Which topic will be conducted is based on the operation mode which can be one of the following:
* Autonomy
* Stopped
* Teleoperation

For *Autonomy* and *Teleoperation* the respective topic is propagated to the motor controller interface. If the operation mode is set to *Stopped* a command velocity of zero for all directions is published. The operation mode can be set through the GUI by a service Robot Control Mux is providing. It is published to the GUI for display as well. If a teleoperation command is issued, the mode automatically switches to *Teleoperation*.

If the software emergency stop is activated in the GUI, the operation mode is handled as *Stopped* and cannot be changed until the stop button is released again.

### Service Provider

The Service Provider handles the communication between the different states and saves data throughout state transitions. Therefore it offers a lot of services to save and retrieve variables for the core functionality of the statemachine.

It offers all services to control waypoint following which include adding, moving and removing single waypoints, setting their `visited` and `unreachable` variables and the routine to be executed upon reaching the waypoint. Furthermore, all waypoints can be retrieved and reset which effectively sets `visited` and `unreachable` to false. The waypoint following mode can be set and the list of all available routines retrieved. The latter is given as a parameter to the Service Provider. The list of waypoints is also published.

For setting and retrieving the current navigation goal the Service Provider is offering services. In addition previously failed goals can be set, retrieved or reset. These serve as a way of blacklisting goals.

The current robot pose can be retrieved and is calculated from the transform from the map to the robot's base footprint.

The service provider also hosts services for exploration


### Non-customizable states 

## Usage

### 