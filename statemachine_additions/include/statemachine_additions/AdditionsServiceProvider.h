#include <ros/ros.h>

#include <geometry_msgs/Pose.h>
#include <geometry_msgs/PoseArray.h>
#include <visualization_msgs/Marker.h>
#include <visualization_msgs/MarkerArray.h>

#include <std_srvs/SetBool.h>
#include <std_msgs/Bool.h>
#include <std_srvs/Empty.h>

#include <statemachine_msgs/GetCmdVelRecording.h>
#include <std_srvs/Trigger.h>
#include <std_srvs/SetBool.h>
#include <geometry_msgs/Twist.h>
#include <boost/circular_buffer.hpp>

#include <move_base_msgs/MoveBaseAction.h>
#include <actionlib/server/simple_action_server.h>

typedef actionlib::SimpleActionServer<move_base_msgs::MoveBaseAction> MoveBaseActionServer;

namespace statemachine {

/**
 * @class AdditionsServiceProvider
 * @brief Class that establishes communication between the different states and the statemachine's
 * 		  periphery including the GUI for the states and classes defined in statemachine additions package. It offers
 * 		  services and publishes topics based on the variables that need to be saved during state transitions.
 */
class AdditionsServiceProvider {

public:
	AdditionsServiceProvider();
	~AdditionsServiceProvider();
	void publishTopics();

private:
	ros::NodeHandle _nh;

	ros::ServiceServer _start_stop_cmd_vel_recording_service;
	ros::ServiceServer _get_cmd_vel_recording_service;
	ros::ServiceServer _reset_cmd_vel_recording_service;
	ros::ServiceServer _request_reverse_path_usage_service;
	ros::ServiceServer _reset_reverse_path_usage_service;
	ros::Subscriber _reverse_path_cmd_vel_subscriber;

	ros::ServiceClient _set_rona_reverse_on;
	ros::ServiceClient _set_rona_reverse_off;

	ros::ServiceServer _set_reverse_mode_service;
	ros::ServiceServer _get_reverse_mode_service;
	ros::Publisher _reverse_mode_publisher;
	ros::Subscriber _reverse_mode_cmd_vel_subscriber;
	ros::Publisher _reverse_mode_cmd_vel_publisher;

	ros::Subscriber frontiers_marker_array_subscriber;
	ros::Publisher frontier_poses_publisher;

	/**
	 * SimpleActionServer for making Explore Lite run and lead it to believe it talks to Move Base
	 */
	MoveBaseActionServer* as;
	/**
	 * Is reverse path state usage active
	 */
	bool _reverse_path_used;
	/**
	 * Circular buffer for the last cmd vel messages to be recorded
	 */
	boost::circular_buffer<geometry_msgs::Twist> _cmd_vel_msgs;
	/**
	 * Size of the circular buffer
	 */
	int _msg_buffer_size;
	/**
	 *Topic name for the autonomy cmd vel topic to be recorded
	 */
	std::string _autonomy_cmd_vel_topic;
	/**
	 * Is currently driving in reverse
	 */
	bool _reverse_mode_active;
	/**
	 * Is the Navigation stack used as Plugin for navigation
	 */
	bool _navigation_plugin_used;

	/**
	 * List of all extracted frontier centers
	 */
	geometry_msgs::PoseArray _frontier_poses;

	bool startStopCmdVelRecording(std_srvs::SetBool::Request &req,
			std_srvs::SetBool::Response &res);
	bool getCmdVelRecording(statemachine_msgs::GetCmdVelRecording::Request &req,
			statemachine_msgs::GetCmdVelRecording::Response &res);
	bool resetCmdVelRecording(std_srvs::Trigger::Request &req,
			std_srvs::Trigger::Response &res);
	bool requestReversePathUsage(std_srvs::Trigger::Request &req,
			std_srvs::Trigger::Response &res);
	bool resetReversePathUsage(std_srvs::Trigger::Request &req,
			std_srvs::Trigger::Response &res);
	/**
	 * Callback for receiving autonomy cmd vel messages and save the ones not equals zero in the cirular buffer
	 * @param msg Cmd vel autonomy message
	 */
	void cmdVelCallback(const geometry_msgs::Twist::ConstPtr& msg);

	bool setReverseMode(std_srvs::SetBool::Request &req,
			std_srvs::SetBool::Response &res);
	bool getReverseMode(std_srvs::Trigger::Request &req,
			std_srvs::Trigger::Response &res);
	/**
	 * Publish if reverse mode is active
	 */
	void publishReverseMode();
	void reverseModeCmdVelCallback(
			const geometry_msgs::Twist::ConstPtr& cmd_vel);
	/**
	 * Set Rona to reverse mode on or off depending on the parameter
	 * @param on If Rona should be set to on or off
	 * @return Returns true if the mode was set successfully, false otherwise
	 */
	bool setReverseModeRona(bool on);
	/**
	 * Callback for requests to the SimpleActionServer that just responds with "Goal reached"
	 * @param frontier_goal
	 */
	void navigationGoalCallback(
			const move_base_msgs::MoveBaseGoalConstPtr& frontier_goal);
	/**
	 * Callback for frontier visualization generated by Explore Lite. Extracts the centers of these
	 * frontiers and saves them in a list
	 * @param frontiers Marker list containing frontiers as points and nearest frontier points for
	 * each frontier as sphere
	 */
	void frontierCallback(
			const visualization_msgs::MarkerArray::ConstPtr& frontiers);
	/**
	 * Publish list of extracted frontier centers for further calculation
	 */
	void publishFrontierPoses();
};

}
